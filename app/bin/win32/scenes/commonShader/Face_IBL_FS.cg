// Ashikmin BRDF model
float2 ASNganBRDF(
			in float3 n,
			in float3 v,
			in float3 l,
			in float3 diffuse,
			in float exponent,
			in float fresnel) 
{
   static const float INV_PI = 0.3183098861;
   static const float PI_23  = 72.256631032;
   static const float PI_8   = 25.132741228;

   const float  r = (diffuse.x+diffuse.y+diffuse.z)*0.333333;

   const float3 h = normalize(l-v);
   const float3 vn = float3(v.x/20.0, v.y/20.0, v.z/20.0);

   const float normalization = (exponent+1.0)/PI_8;

   const float VDotH = max(dot(-vn,h),0.0);
   const float NDotH = max(dot(n,h),0.0);
   const float NDotV = max(dot(n,-vn),0.0);
   const float NDotL = max(dot(n,l),0.0);

   return float2(
	   max((pow(NDotH,exponent)/(VDotH*max(NDotL,NDotV)))*normalization*(fresnel+(1.0-fresnel)*pow(VDotH,5.0)), 0.0),
	   max(((28.0*r)/PI_23)*(1.0-fresnel)*(1.0-pow(1.0-(NDotL/2.0),5.0))*(1.0-pow(1.0-(NDotV/2.0),5.0)), 0.0) ) * NDotL;
}

// Expand a range-compressed vector
float3 expand(float3 v)
{
	return (v - 0.5) * 2;
}

void Face_IBL_FS_TS(   
				//in 
			    float2 uv			: TEXCOORD0,				
				float3 light_vector : TEXCOORD1,
			    float3 half_angle   : TEXCOORD2,							
			    //out
				out float4 result	: COLOR,
				//parameter				
				uniform float4 lightDiffuse,
				uniform float4 ambientLight,
				uniform float4 specularLight,
				uniform float specular_power,
				uniform float bumpiness,
				// textures
				uniform sampler2D	base_map		: register(s0),
				uniform sampler2D	bump_map		: register(s1),
				uniform sampler2D	specular_map	: register(s2))
{

  float3 base = tex2D( base_map, uv );
  float3 bump = tex2D( bump_map, uv );
  float specularLevel = tex2D(specular_map, uv).b;

  //normalise
  float3 normalized_light_vector = normalize( light_vector );
  float3 normalized_half_angle = normalize( half_angle );
   
  // "Smooth out" the bump based on the bumpiness parameter.
  // This is simply a linear interpolation between a "flat"
  // normal and a "bumped" normal.  Note that this "flat"
  // normal is based on the texture space coordinate basis.
  float3 smooth = { 0.5f, 0.5f, 1.0f };
  bump = lerp( smooth, bump, bumpiness );
  bump = normalize( ( bump * 2.0f ) - 1.0f );  
  

  // These dot products are used for the lighting model
  // equations.  The surface normal dotted with the light
  // vector is denoted by n_dot_l.  The normal vector
  // dotted with the half angle vector is denoted by n_dot_h.
  float n_dot_l = dot( bump, normalized_light_vector );
  float n_dot_h = dot( bump, normalized_half_angle );

  // Calculate the resulting pixel color,
  // based on our lighting model.
  // Ambient + Diffuse + Specular
  result.rgb =
     ( base * ambientLight) +
     ( base * lightDiffuse * max( 0.0f, n_dot_l ) ) +
     ( specularLight * specularLevel * pow( max( 0.0f, n_dot_h ), specular_power ) );

  //result.rgb = normalize(iTangent) * 0.5 + float3(0.5, 0.5, 0.5);
  result.a = 1.0f; //** Set the alpha component manually

  // try lit function
  //float4 Lit = lit(n_dot_l,n_dot_h, 127);
  //result.xyz = base * lightDiffuse * Lit.y + specularLight * specularLevel * Lit.z +  base * ambientLight;
			
}

void Face_IBL_FS(   //in 
			    float2 iTexCoord	: TEXCOORD0,				
			    float3 iNormal		: TEXCOORD1,
				float3 iTangent		: TEXCOORD2,
				float3 iBinormal	: TEXCOORD3,				
				float3 iView		: TEXCOORD4,				
			    //out
				out float4 result	: COLOR,
				//parameter				
				uniform float	exposure,
				uniform float4	fvAmbient,
				uniform float4  fvSpecular,
				uniform float4	fvDiffuse,				
				uniform float	RimLightPower,	
				uniform float4	RimLightColor,	
				uniform float	bloodFactor,	
				uniform float	bloodPower,		
				uniform float	Occlusion,		
				uniform float	BumpDepth,		
				uniform float4	SSSColor,		
				uniform float	SSSPower,		
				uniform float	SSSFactor,		
				uniform float	SwitchBump,
				uniform float	poreSpec,		
				uniform float	lipSpec,		
				uniform float	RimLightFactor,
				uniform float	hairShadow,
				uniform float	SpecPower,
				// textures
				uniform sampler2D	baseMap		: register(s0),
				uniform sampler2D	bumpMap		: register(s1),
				uniform sampler2D	SSSMap		: register(s2),
				uniform sampler2D	specularMap	: register(s3),				
				uniform samplerCUBE DiffuseCube	: register(s4),
				uniform samplerCUBE SpecCube	: register(s5))
				//uniform sampler2D	baseMap		: register(s8),
				//uniform sampler2D	bumpMap		: register(s9),
				//uniform sampler2D	SSSMap		: register(s10),
				//uniform sampler2D	specularMap	: register(s11),				
				//uniform samplerCUBE DiffuseCube	: register(s12),
				//uniform samplerCUBE SpecCube	: register(s13))
{	
	// generate Normal
	float3 NeutralNormal;
	NeutralNormal.r = 0.5;
	NeutralNormal.g = 0.5;
	NeutralNormal.b = 1.0;
	float3 bumpSample = NeutralNormal;
	float4 SpecularRimBumpfactor = tex2D(specularMap, iTexCoord);
	float4 bloodLayer = tex2D(SSSMap, iTexCoord);
     
	//bend normal
	iNormal.z *= -1; // seim was here ;)
	bumpSample = lerp(NeutralNormal, tex2D( bumpMap, iTexCoord ).xyz, BumpDepth * SpecularRimBumpfactor.b);
   	float3 extendedSample   = expand( bumpSample);
	float3 fvNormal         = normalize( iNormal + (iTangent * extendedSample.x) + (iBinormal * extendedSample.y));
	//fvNormal.z *= -1; // seim was here ;)

	float DiffCubeValue = texCUBE(DiffuseCube, fvNormal) * exposure;
	float3 fvView = normalize( iView );
	float3 Reflect = reflect(fvView, fvNormal);
	float SpecCubeValue = texCUBE(SpecCube, Reflect) * exposure; 
	float  fNDotV           = dot(iNormal, fvView); 
	float4 fvBaseColor      = tex2D( baseMap, iTexCoord );

	// extract Occlusion Map
	float Occ = fvBaseColor.a;
      
	// calculate standard ambient, diffuse and specular
	float4 fvTotalAmbient   = fvAmbient * fvBaseColor; 	
	float4 fvTotalDiffuse   = fvDiffuse * DiffCubeValue * fvBaseColor; 
		  
    float4 fvTotalSpecular  = fvSpecular * SpecCubeValue * (SpecularRimBumpfactor.r + poreSpec * SpecularRimBumpfactor.a);
    fvTotalSpecular += (bloodLayer.a * lipSpec) * SpecCubeValue;

	// calculate SSS
	float SSS = saturate(pow(1-fNDotV, SSSPower) * DiffCubeValue);
	float4 SSSLight = SSS * SSSColor * SSSFactor;
  
    // calculate Rim Light
    float RimLightStrength = saturate(pow(1-fNDotV, RimLightPower) * DiffCubeValue);
	float4 RimLight = RimLightStrength * RimLightColor * SpecularRimBumpfactor.g * RimLightFactor;	
	
    // calculate blood influence
    float bloodStrength = saturate(pow(1-fNDotV, bloodPower) * DiffCubeValue);
   
	float4 blood = bloodLayer * (1-bloodStrength) * bloodFactor;

    float4 comp = (0,0,0,0);
    comp += fvTotalAmbient;   
    comp += fvTotalDiffuse;      
    comp += fvTotalSpecular * SpecPower;   
    comp += blood;      
    comp += RimLight;     
    comp += SSSLight;   
    float4 UnOccluded = saturate(comp);
    float4 FinalColor = UnOccluded;
    float4 shadowColor = float4 (0.15, 0.01, 0.0, 1.0);   
    float4 Occluded = lerp(shadowColor, UnOccluded * Occ, Occ);
    FinalColor = lerp(UnOccluded, Occluded, Occlusion);
	FinalColor = lerp(FinalColor, FinalColor * SpecularRimBumpfactor.b, hairShadow);
	result = FinalColor;		
		
}

void Face_IBL_FS_BRDF(   //in 
			    float2 iTexCoord	: TEXCOORD0,				
			    float3 iNormal		: TEXCOORD1,
				float3 iTangent		: TEXCOORD2,
				float3 iBinormal	: TEXCOORD3,				
				float3 iView		: TEXCOORD4,				
			    //out
				out float4 result	: COLOR,
				//parameter
				uniform float		nbLights,      
				uniform float		exponent,  
				uniform float		fresnel,   
				uniform float3		diffuse,   
				uniform float3		specular,    
				uniform float		lightscale,   
				uniform float		envsize,   
				uniform float		exposure,
				uniform float4		fvAmbient,
				uniform float4		fvSpecular,
				uniform float4		fvDiffuse,				
				uniform float		RimLightPower,	
				uniform float4		RimLightColor,
				uniform float3		shadowColor,
				uniform float		bloodFactor,	
				uniform float		bloodPower,		
				uniform float		Occlusion,		
				uniform float		BumpDepth,		
				uniform float3		SSSColor,		
				uniform float		SSSPower,		
				uniform float		SSSFactor,		
				uniform float		poreSpec,		
				uniform float		lipSpec,		
				uniform float		RimLightFactor,
				uniform float		hairShadow,
				uniform float		SpecPower,
				// textures
				uniform sampler2D	baseMap		: register(s0),
				uniform sampler2D	bumpMap		: register(s1),
				uniform sampler2D	SSSMap		: register(s2),
				uniform sampler2D	specularMap	: register(s3),				
				uniform samplerCUBE DiffuseCube	: register(s4),
				uniform samplerCUBE SpecCube	: register(s5),
				uniform sampler1D lightDirs		: TEXUNIT6, // array of light directions in camera space (lx,ly,lz)
				uniform sampler1D lightPows		: TEXUNIT7) //array of light colors - rgb intensities (r,g,b)
{	
	// generate Normal
	static const float3 NeutralNormal = float3(0.5, 0.5, 1.0);
	const float4 SpecularRimBumpfactor = tex2D(specularMap, iTexCoord);
     
	//bend normal
	const float3 extendedSample   = expand(lerp(NeutralNormal, tex2D(bumpMap, iTexCoord ).xyz, BumpDepth * SpecularRimBumpfactor.b));
	const float3 fvNormal         = normalize(iNormal + (iTangent * extendedSample.x) + (iBinormal * extendedSample.y));

	const float  fNDotV           = dot(iNormal, iView); 
	
	// texture lookups
	const float4 fvBaseColor      = tex2D(baseMap, iTexCoord);
	const float4 bloodLayer		  = tex2D(SSSMap, iTexCoord);
  
	float2 brdf;
	float3 l,p;
	float3 brdfSpec = float3(0.0);
	float3 brdfDiff = float3(0.0);
	const float s   = 1.0/nbLights;

	for(float i=0.0; i<1.0; i+=s) {
		l = tex1D(lightDirs, i).xyz / lightscale;
		p = tex1D(lightPows, i).xyz;
		
		brdf = ASNganBRDF(fvNormal, iView, l, diffuse, exponent, fresnel);
		brdfSpec += p * brdf.x;
		brdfDiff += p * brdf.y;
	}

	float3 comp = specular * brdfSpec * SpecPower * ((SpecularRimBumpfactor.r + poreSpec * SpecularRimBumpfactor.a) + (bloodLayer.a * lipSpec));  // specular
    comp	+= diffuse * brdfDiff * fvBaseColor.xyz;  // diffuse
	comp	/= envsize;  // brdf scaling
	comp	+= fvAmbient * fvBaseColor.xyz;	// ambient
	comp	+= bloodLayer.rgb * (1.0 - saturate(pow(1.0 - fNDotV, bloodPower) * brdfDiff)) * bloodFactor;  // blood
	comp	+= saturate(pow(1.0-fNDotV, SSSPower) * brdfDiff) * SSSColor * SSSFactor;  // SSS

	float3 UnOccluded = saturate(comp);
	float3 Occluded = lerp(shadowColor, UnOccluded * fvBaseColor.a, fvBaseColor.a);

	float3 finalColor = lerp(UnOccluded, Occluded, Occlusion);
	finalColor = lerp(finalColor, finalColor * SpecularRimBumpfactor.b, hairShadow);

	result = float4(finalColor, 1.0);
}